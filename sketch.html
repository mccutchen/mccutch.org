<!DOCTYPE html>
<html>

<head>
    <title></title>
    <meta charset="utf8">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            margin: 0;
            padding: 5em;
            width: 100%;
            height: 100%;
        }

        body {
            background: #fff;
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
        }

        canvas {
            width: 100%;
            height: 100%;
        }
    </style>
    <script src="noise.js"></script>>
</head>

<body>
    <canvas>
        McCUTCHEN
    </canvas>
</body>

<script>
    (function () {
        function setupCanvas(canvas) {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            const ctx = canvas.getContext('2d');
            // ctx.scale(dpr, dpr);
            return ctx;
        }

        function init() {
            const canvas = document.getElementsByTagName("canvas")[0];
            const ctx = setupCanvas(canvas);

            const width = canvas.width;
            const height = canvas.height;

            const noise = new SimplexNoise();

            let curr = new Vector(Math.floor(canvas.width / 2), Math.floor(canvas.height / 2));
            let prev = new Vector(curr.x, curr.y);

            let t = 0;
            function step() {
                let n = noise.noise3d(prev.x * 1000, prev.y * 1000, t * 100000);
                let r = n * 6.370452;
                // let step = rand(3, 10);
                let step = 10;
                let dx = step * Math.cos(r);
                let dy = step * Math.sin(r);

                prev = curr;
                curr = curr.add(new Vector(dx, dy));
                curr.bounce(width, height);

                // console.log(n, prev, curr);

                // console.log(prev, curr, velocity, acceleration);

                ctx.lineWidth = 3;
                ctx.strokeStyle = '#333';
                ctx.beginPath();
                ctx.moveTo(prev.x | 0, prev.y | 0);
                ctx.lineTo(curr.x | 0, curr.y | 0);
                ctx.stroke();

                t++;
            }

            // window.setInterval(step, 1000);

            (function loop() {
                window.requestAnimationFrame(function () {
                    step()
                    loop();
                });
            })();
        }

        function rand(min, max) {
            return Math.random() * (max - min) + min;
        }

        function randInt(min, max) {
            return rand(min, max) | 0;
        }

        class Vector {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }

            add(other) {
                return new Vector(this.x + other.x, this.y + other.y);
            }

            magnitude() {
                return Math.sqrt(this.x ** 2 + this.y ** 2);
            }

            limit(limit) {
                var m = this.magnitude();
                if (m > limit) {
                    this.scale((1 / m) * limit);
                    // this.scale(1 / m);
                    // this.scale(limit);
                }
                return this;
            }

            normalize() {
                let m = this.magnitude();
                if (m !== 0 && m !== 1) {
                    return this.scale(1 / m);
                }
                return this;
            }

            scale(n) {
                this.x *= n;
                this.y *= n;
                return this;
            }

            wrap(xLimit, yLimit) {
                if (this.x < 0) {
                    this.x += xLimit;
                } else if (this.x > xLimit) {
                    this.x %= xLimit;
                }
                if (this.y < 0) {
                    this.y += yLimit;
                } else if (this.y > yLimit) {
                    this.y %= yLimit;
                }
            }

            bounce(xLimit, yLimit) {
                if (this.x < 1) {
                    this.x = 1;
                } else if (this.x >= xLimit) {
                    this.x = xLimit - 1;
                }
                if (this.y < 1) {
                    this.y = 1;
                } else if (this.y >= yLimit) {
                    this.y = yLimit - 1;
                }
            }
        }

        init();
    })();
</script>

</html>
